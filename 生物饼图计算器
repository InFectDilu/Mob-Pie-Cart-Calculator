#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
#include <string>
#include <sstream>
#include <limits>
#include <algorithm>
#include <fstream>

#ifdef _WIN32
#include <windows.h>
#endif

using namespace std;

const double PI = 3.14159265358979323846;

// 定义点的结构
struct Point {
    double x;
    double y;

    Point(double x = 0, double y = 0) : x(x), y(y) {}

    // 重载相等运算符，考虑浮点数精度
    bool operator==(const Point& other) const {
        return abs(x - other.x) < 1e-10 && abs(y - other.y) < 1e-10;
    }
};

// 定义圆的结构
struct Circle {
    Point center;
    double radius;

    Circle(double x = 0, double y = 0, double r = 0) : center(x, y), radius(r) {}
};

// 从剪贴板获取文本（仅Windows）
string getClipboardText() {
#ifdef _WIN32
    if (!OpenClipboard(nullptr)) {
        return "";
    }

    HANDLE hData = GetClipboardData(CF_TEXT);
    if (hData == nullptr) {
        CloseClipboard();
        return "";
    }

    char* pszText = static_cast<char*>(GlobalLock(hData));
    if (pszText == nullptr) {
        CloseClipboard();
        return "";
    }

    string text(pszText);
    GlobalUnlock(hData);
    CloseClipboard();

    return text;
#else
    return "";
#endif
}

// 从F3+C命令字符串提取坐标（不提取角度）
bool extractCoordinatesFromCommand(const string& command, double& x, double& y) {
    istringstream iss(command);
    string token;
    vector<string> tokens;

    // 分割字符串为token
    while (iss >> token) {
        tokens.push_back(token);
    }

    // 检查是否具有足够的token
    if (tokens.size() < 11) {
        cout << "命令格式错误，无法提取坐标" << endl;
        return false;
    }

    try {
        // 提取x坐标（第7个token，索引6）
        x = stod(tokens[6]);

        // 提取y坐标（第9个token，索引8）
        y = stod(tokens[8]);

        return true;
    }
    catch (const exception& e) {
        cout << "提取坐标时出错: " << e.what() << endl;
        return false;
    }
}

// 检查字符串是否为数字
bool isNumber(const string& s) {
    if (s.empty()) return false;

    // 检查是否包含非数字字符（除了小数点、负号和数字）
    return all_of(s.begin(), s.end(), [](char c) {
        return isdigit(c) || c == '.' || c == '-';
        });
}

// 从字符串解析坐标（第一个圆不提取角度）
bool parseCoordinates(const string& input, double& x, double& y, double& angle, bool& isCommand, bool isFirstCircle = false) {
    // 检查是否为F3+C命令格式
    if (input.find("/execute") == 0) {
        isCommand = true;
        if (isFirstCircle) {
            // 第一个圆不提取角度
            return extractCoordinatesFromCommand(input, x, y);
        }
        else {
            // 第二个圆提取角度
            istringstream iss(input);
            string token;
            vector<string> tokens;

            while (iss >> token) {
                tokens.push_back(token);
            }

            if (tokens.size() < 11) {
                cout << "命令格式错误，无法提取坐标和角度" << endl;
                return false;
            }

            try {
                x = stod(tokens[6]);
                y = stod(tokens[8]);
                angle = stod(tokens[9]);
                return true;
            }
            catch (const exception& e) {
                cout << "提取坐标或角度时出错: " << e.what() << endl;
                return false;
            }
        }
    }

    // 不是命令格式，尝试解析为两个数字
    isCommand = false;
    angle = 0.0; // 非命令格式没有角度信息

    istringstream iss(input);
    string token1, token2;

    if (iss >> token1 >> token2) {
        if (isNumber(token1) && isNumber(token2)) {
            try {
                x = stod(token1);
                y = stod(token2);
                return true;
            }
            catch (const exception& e) {
                cout << "解析坐标时出错: " << e.what() << endl;
                return false;
            }
        }
    }

    cout << "输入格式错误，请输入F3+C命令或x y坐标" << endl;
    return false;
}

// 规范化角度到[-180, 180]范围
double normalizeAngle(double angle) {
    // 先转换为度
    angle = fmod(angle, 360.0);
    if (angle > 180.0) {
        angle -= 360.0;
    }
    else if (angle < -180.0) {
        angle += 360.0;
    }
    return angle;
}

// 计算从圆心到目标点的向量与Y轴正方向的夹角（顺时针为负，逆时针为正）
double calculateAngle(const Point& from, const Point& to) {
    double dx = to.x - from.x;
    double dy = to.y - from.y;

    // 计算与X轴正方向的夹角（标准数学坐标系）
    double angle_rad = atan2(dy, dx);

    // 转换为度
    double angle_deg = angle_rad * 180.0 / PI;

    // 转换为与Y轴正方向的夹角（顺时针为负，逆时针为正）
    // 标准数学坐标系中，Y轴正方向对应90°，我们需要将其转换为0°
    // 同时，顺时针旋转为负，逆时针旋转为正
    angle_deg = 90.0 - angle_deg;

    // 确保顺时针为负，逆时针为正
    angle_deg = -angle_deg;

    return normalizeAngle(angle_deg);
}

// 计算两个角度之间的最小差值
double angleDifference(double a, double b) {
    double diff = fabs(a - b);
    return min(diff, 360.0 - diff);
}

// 根据角度获取方向描述
string getDirection(double angle) {
    // 将角度规范化为[0, 360)范围
    double normalized = fmod(angle + 360.0, 360.0);

    // 定义方向
    if (normalized >= 337.5 || normalized < 22.5) return "南";
    else if (normalized >= 22.5 && normalized < 67.5) return "西南";
    else if (normalized >= 67.5 && normalized < 112.5) return "西";
    else if (normalized >= 112.5 && normalized < 157.5) return "西北";
    else if (normalized >= 157.5 && normalized < 202.5) return "北";
    else if (normalized >= 202.5 && normalized < 247.5) return "东北";
    else if (normalized >= 247.5 && normalized < 292.5) return "东";
    else return "东南";
}

// 计算两点之间的距离
double distance(const Point& p1, const Point& p2) {
    return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));
}

// 计算圆心连线与第二个圆的交点
vector<Point> findLineCircleIntersections(const Circle& c1, const Circle& c2) {
    vector<Point> intersections;

    // 计算两圆心之间的距离
    double d = distance(c1.center, c2.center);

    // 如果两圆同心，无法计算交点
    if (d < 1e-10) {
        return intersections;
    }

    // 计算单位向量从c1指向c2
    double dx = (c2.center.x - c1.center.x) / d;
    double dy = (c2.center.y - c1.center.y) / d;

    // 计算圆心连线与第二个圆的交点
    // 这两个点分别在c2圆心两侧，距离为r2
    Point p1(
        c2.center.x + dx * c2.radius,
        c2.center.y + dy * c2.radius
    );

    Point p2(
        c2.center.x - dx * c2.radius,
        c2.center.y - dy * c2.radius
    );

    // 根据半径关系选择点
    if (c2.radius < c1.radius) {
        // 显示距离第一个圆的圆心更远的点
        double dist1 = distance(c1.center, p1);
        double dist2 = distance(c1.center, p2);

        if (dist1 > dist2) {
            intersections.push_back(p1);
        }
        else {
            intersections.push_back(p2);
        }
    }
    else if (c2.radius > c1.radius) {
        // 显示距离第一个圆的圆心更近的点
        double dist1 = distance(c1.center, p1);
        double dist2 = distance(c1.center, p2);

        if (dist1 < dist2) {
            intersections.push_back(p1);
        }
        else {
            intersections.push_back(p2);
        }
    }
    else {
        // 半径相等，显示中点
        Point midpoint(
            (c1.center.x + c2.center.x) / 2,
            (c1.center.y + c2.center.y) / 2
        );
        intersections.push_back(midpoint);
    }

    return intersections;
}

// 计算两圆的交点
vector<Point> findCircleIntersections(const Circle& c1, const Circle& c2) {
    vector<Point> intersections;

    // 计算两圆心之间的距离
    double d = distance(c1.center, c2.center);

    // 检查两圆是否重合
    if (d < 1e-10 && abs(c1.radius - c2.radius) < 1e-10) {
        cout << "两圆重合，有无限多个交点" << endl;
        return intersections; // 返回空向量表示无限多个交点
    }

    // 检查是否没有交点
    if (d > c1.radius + c2.radius || d < abs(c1.radius - c2.radius)) {
        intersections = findLineCircleIntersections(c1, c2);
        if (!intersections.empty()) {
            cout << "两圆没有交点，实际点为：" << endl;
        }
        return intersections;
    }

    // 计算交点
    double a = (pow(c1.radius, 2) - pow(c2.radius, 2) + pow(d, 2)) / (2 * d);
    double h = sqrt(pow(c1.radius, 2) - pow(a, 2));

    // 计算中点坐标
    Point p0(
        c1.center.x + a * (c2.center.x - c1.center.x) / d,
        c1.center.y + a * (c2.center.y - c1.center.y) / d
    );

    // 计算交点坐标
    if (h < 1e-10) { // 相切，只有一个交点
        intersections.push_back(p0);
        cout << "两圆相切，有一个交点" << endl;
    }
    else { // 有两个交点
        intersections.push_back(Point(
            p0.x + h * (c2.center.y - c1.center.y) / d,
            p0.y - h * (c2.center.x - c1.center.x) / d
        ));

        intersections.push_back(Point(
            p0.x - h * (c2.center.y - c1.center.y) / d,
            p0.y + h * (c2.center.x - c1.center.x) / d
        ));

        cout << "两圆相交，有两个交点" << endl;
    }

    return intersections;
}

// 四舍五入到个位数
int roundToInteger(double value) {
    return static_cast<int>(round(value));
}

// 打印交点坐标（保留到个位数）
void printIntersections(const vector<Point>& intersections, const Point& center, double inputAngle = 0.0, bool hasAngle = false) {
    if (intersections.empty()) {
        return;
    }

    // 计算推荐的交点（如果有角度信息）
    int recommendedIndex = -1;
    if (hasAngle && intersections.size() == 2) {
        double angle1 = calculateAngle(center, intersections[0]);
        double angle2 = calculateAngle(center, intersections[1]);

        double diff1 = angleDifference(inputAngle, angle1);
        double diff2 = angleDifference(inputAngle, angle2);

        if (diff1 < diff2) {
            recommendedIndex = 0;
        }
        else if (diff2 < diff1) {
            recommendedIndex = 1;
        }
    }

    // 打印交点信息
    for (size_t i = 0; i < intersections.size(); ++i) {
        int x_rounded = roundToInteger(intersections[i].x);
        int y_rounded = roundToInteger(intersections[i].y);

        cout << "交点 " << i + 1 << ": ("
            << x_rounded << ", "
            << y_rounded << ")";

        // 计算并显示每个交点的角度和方向
        double angle = calculateAngle(center, intersections[i]);
        string direction = getDirection(angle);

        cout << " 角度: " << fixed << setprecision(2) << angle << "° (" << direction << ")";

        // 如果是推荐的交点，添加推荐标记
        if (i == recommendedIndex) {
            cout << " [推荐]";
        }

        cout << endl;
    }
}

// 从options.txt文件中读取renderDistance的值（在整个文件中查找）
bool readRenderDistanceFromOptions(double& renderDistance) {
    ifstream file("options.txt");
    if (!file.is_open()) {
        // 静默失败，不输出错误信息
        return false;
    }

    string line;
    bool found = false;

    // 在整个文件中查找renderDistance
    while (getline(file, line)) {
        // 查找"renderDistance:"的位置
        size_t pos = line.find("renderDistance:");
        if (pos != string::npos) {
            // 提取renderDistance的值
            string valueStr = line.substr(pos + 15); // "renderDistance:"的长度是15
            try {
                renderDistance = stod(valueStr);
                cout << "从options.txt读取的renderDistance值: " << renderDistance << endl;
                found = true;
                break; // 找到第一个renderDistance就退出
            }
            catch (const exception& e) {
                // 静默失败，不输出错误信息
            }
        }
    }

    file.close();
    return found;
}

int main() {
    while (true) {
        string input1, input2;
        double x1, y1, x2, y2;
        double angle1 = 0.0, angle2 = 0.0;
        bool isCommand1 = false, isCommand2 = false;

        cout << "请输入第一个圆的圆心坐标 (F3+C或x y坐标): ";
        getline(cin, input1);

        // 如果输入为空，尝试从剪贴板获取内容
        if (input1.empty()) {
            input1 = getClipboardText();
            if (!input1.empty()) {
                cout << "已从剪贴板粘贴内容: " << input1 << endl;
            }
            else {
                cout << "剪贴板为空或无法访问，请重新输入" << endl;
                continue;
            }
        }

        if (!parseCoordinates(input1, x1, y1, angle1, isCommand1, true)) {
            continue;
        }

        cout << "提取的坐标: x = " << x1 << ", y = " << y1 << endl;

        // 从options.txt读取第一个圆的半径
        double r1_input;
        bool readSuccess1 = readRenderDistanceFromOptions(r1_input);
        bool fileReadFailed = !readSuccess1; // 记录文件读取是否失败

        if (!readSuccess1) {
            // 循环直到输入有效的半径值
            while (true) {
                cout << "请手动输入第一个圆的半径 (r1): ";
                string r1_input_str;
                getline(cin, r1_input_str);

                // 检查输入是否为空
                if (r1_input_str.empty()) {
                    cout << "输入不能为空，请重新输入。" << endl;
                    continue;
                }

                // 尝试将输入转换为数字
                try {
                    r1_input = stod(r1_input_str);
                    break; // 输入有效，退出循环
                }
                catch (const exception& e) {
                    cout << "输入无效，请输入一个有效的数字。" << endl;
                }
            }
        }

        cout << "请输入第二个圆的圆心坐标 (F3+C或x y坐标): ";
        getline(cin, input2);

        // 如果输入为空，尝试从剪贴板获取内容
        if (input2.empty()) {
            input2 = getClipboardText();
            if (!input2.empty()) {
                cout << "已从剪贴板粘贴内容: " << input2 << endl;
            }
            else {
                cout << "剪贴板为空或无法访问，请重新输入" << endl;
                continue;
            }
        }

        if (!parseCoordinates(input2, x2, y2, angle2, isCommand2, false)) {
            continue;
        }

        cout << "提取的坐标: x = " << x2 << ", y = " << y2;
        if (isCommand2) {
            angle2 = normalizeAngle(angle2);
            cout << ", 角度: " << angle2 << "°";
        }
        cout << endl;

        // 从options.txt读取第二个圆的半径
        double r2_input;
        bool readSuccess2 = false;

        // 如果第一个圆已经无法读取options.txt，第二个圆直接手动输入
        if (fileReadFailed) {
            readSuccess2 = false;
        }
        else {
            readSuccess2 = readRenderDistanceFromOptions(r2_input);
        }

        if (!readSuccess2) {
            // 循环直到输入有效的半径值
            while (true) {
                cout << "请手动输入第二个圆的半径 (r2): ";
                string r2_input_str;
                getline(cin, r2_input_str);

                // 检查输入是否为空
                if (r2_input_str.empty()) {
                    // 使用默认值：第一个圆的半径
                    r2_input = r1_input;
                    cout << "使用默认半径值: r2 = r1 = " << r2_input << endl;
                    break;
                }

                // 尝试将输入转换为数字
                try {
                    r2_input = stod(r2_input_str);
                    break; // 输入有效，退出循环
                }
                catch (const exception& e) {
                    cout << "输入无效，请输入一个有效的数字。" << endl;
                }
            }
        }

        // 将输入的半径乘以16
        double r1 = r1_input * 16.0;
        double r2 = r2_input * 16.0;

        Circle c1(x1, y1, r1);
        Circle c2(x2, y2, r2);

        vector<Point> intersections = findCircleIntersections(c1, c2);

        // 打印交点信息
        if (isCommand2) {
            printIntersections(intersections, c2.center, angle2, true);
        }
        else {
            printIntersections(intersections, c2.center);
        }

        cout << "----------------------------------------" << endl;
        cout << "准备进行下一次计算...（Bilibili: InFect狄鹿）" << endl;
        cout << "----------------------------------------" << endl;

        // 清空输入缓冲区，确保下一次循环正常
        cin.clear();
    }

    return 0;
}
